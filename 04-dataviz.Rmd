# Data Visualization with `ggplot2` {#dataviz}

```{r ch4-pkgs, include=FALSE}
library(tidyverse)
library(scales)
library(kableExtra)
```

## Objectives

This chapter is designed around the following learning objectives for basic
data visualization in R. Upon completing this chapter, you should be able to:  

- Install, load, and use `ggplot2` functions to visualize dataframe elements
- Differentiate between data, aesthetics, and layers in a `ggplot2` object
- Determine how to change color and shape elements in a `ggplot2` layer
- Create, store, and save a `ggplot2` object in an R script

## Install and load `ggplot2`

> <span style="color: blue;"> "The best design gets out of the way between the viewerâ€™s brain and the content." - Edward Tufte </span>

In this chapter, you will learn how to make basic plots using the `ggplot2`
package in R, which is another package in `tidyverse`, like `dplyr` from
Chapter 2. This section will focus on making **useful**, rather than
**attractive** graphs because, at this stage, we are focusing on exploring data
rather than presenting results to others. Later on, I will explain more about
how you can customize `ggplot2` objects to help you make plots that "get out of
the way" between content you wish to present and the viewer's brain, where you
hope understanding takes root.  

If you don't already have `ggplot2` installed, you'll need to install it. You
then need to load the package in your current session of R:

```{r load-ggplot2, eval=FALSE}
# install ggplot2 package (done once per R/RStudio installation)
install.packages("ggplot2")  
# load ggplot2 in current R session
library(ggplot2)
```

Alternatively, if you are planning on using other `tidyverse` R packages in the
same R session, you can simply install (if needed) and load the `tidyverse` "R
package suite of R packages" with `library(tidyverse)`.

## Steps to create a `ggplot2` object

The process of creating a plot using `ggplot2` follows conventions that are a
bit different than most of the code you've seen so far in R, although it is
somewhat similar to the idea of piping I introduced in the last chapter. The
basic steps behind creating a plot with `ggplot2` are:

1. Create an object of the `ggplot2` class, typically specifying the **data** and some or all of the **aesthetics**

2. Add a layer or **geom** to the plot, along with other specific elements, using `+`

**Aesthetics** or `aes()` in R represent the things that we are plotting: the x
and y data. **Geoms** like `geom_point()` represent the way in which we layer
the aesthetics onto the plot. The geom is the type of plot that we are calling.

You can layer on one or many geoms and other elements to create plots that
range from very simple to very customized. We will start by focusing on simple
geoms and added elements; later on, we will explore more options for
customization. 

```{block type="rmdwarning"}
A common error when writing `ggplot2` code is to put the `+` to add a geom or
element at the beginning of a line rather than the end of a previous line. In
this case, R will try to execute the call too soon. If R gets to the end of a
line and there is no indication to continue the call (e.g., `%>%` for piping or
`+` for `ggplot2` plots), R interprets that as a message to run the call
without reading in further code. Thus, to avoid errors, be sure to end each
line in `ggplot2` calls with `+`, except for the final line when the call is
actually done. Don't start lines with `+`. 
```

## Initializing a `ggplot2` object

The first step in creating a plot using `ggplot()` is to create a ggplot
object. This object will not, by itself, create a plot with anything in it.
Instead, this first step typically specifies the data frame you want to use and
which aesthetics will be mapped to certain columns of that data frame.
Aesthetics are explained more in the next subsection.

Outside of a pipeline, you can use the following conventions to initialize a
`ggplot2` object:

```{r ggplot2-generic, eval=FALSE}
## generic code; will not run
object <- ggplot(my_dataframe, aes(x = data_column_1, y = data_column_2))
```

The dataframe is the first parameter in a `ggplot()` function and, if you like,
you can use the parameter definition with that call (e.g., `data = dataframe`).
Aesthetics are defined within an `aes()` function call that is typically
defined within the `ggplot()` function. 

```{block type="rmdnote"}
While the `ggplot()` call is the place where you will most often see an `aes()`
call, you can also make calls to `aes()` within the calls to specific geoms.
This can be particularly useful if you want to map aesthetics differently for
different geoms in your plot. We'll see some examples of this use of `aes()`
more in later sections, when we talk about customizing plots. The `data`
parameter can also be used in geom calls in order to use a different dataframe
from the one defined when creating the original ggplot object, although this is
less common. 
```

## Plot aesthetics

**Aesthetics** are properties of the plot that can show certain elements of the
data. For example, in Figure \@ref(fig:mpg-bar), we call an x-axis aesthetic 
(`x = class`) from the `mpg` dataset. We then plot counts of cars within
different vehicle classes using `geom_bar()`. The `mpg` dataframe is included
in the `ggplot2` package; you can learn more about it by typing `?mpg` (no
parentheses) into the console after loading `ggplot2` with `library(ggplot2)`.
You can also learn more by typing `str(mpg)` and `head(mpg)`. As seen in
Chapters 2 and 3, one should always *look* at the data upon import and examine 
the dataframe structure and variable classes.

According to `?mpg`:  

> "This dataset contains a subset of the fuel economy data that the EPA makes available on [http://fueleconomy.gov](http://fueleconomy.gov). It contains only models which had a new release every year between 1999 and 2008 - this was used as a proxy for the popularity of the car."

```{r mpg-bar, warning=FALSE, message=FALSE, fig.cap="Example of a simple call to `ggplot` showing counts of vehicle classes from the `mpg` dataframe."}

# use ggplot() to map the data and a single aesthetic (variable = class)
ggplot(data = mpg, aes(x = class)) + 
  geom_bar() # call to a specific geom to plot the mapped data
```

Let's call this plot again with a second aesthetic, the `fill` color, which
will be mapped to vehicle drive type (i.e., 4-wheel, font-wheel, or
rear-wheel). The x-position will continue to show vehicle class, and the
y-position will show the counts of vehicles, now colored by the drive types.

```{r mpg-fill, warning=FALSE, message=FALSE, fig.cap="Example of a call to `ggplot` showing counts of vehicle classes from the `mpg` dataframe and colored by the `fill` aesthetic mapped to drive type (`drv`)."}

# call to ggplot to map the data and a single aesthetic
ggplot(data = mpg, aes(x = class, fill = drv)) +
  geom_bar()  # call to a specific geom to plot the mapped data
```

```{block type="rmdnote"}
`ggplot()` will choose colors and add legends to plots when an aesthetic
mapping creates such opportunities. You will learn ways to customize colors,
legends, and other plot elements later.
```

Which aesthetics are required for a plot depend on which geoms (more on those
in a second) you're adding to the plot. You can find out the aesthetics you can
use for a geom in the "Aesthetics" section of the geom's helpfile (e.g.,
`?geom_bar`). Required aesthetics are in bold in this section of the helpfile
and optional ones are not. Common plot aesthetics you might want to specify
include: 

```{r aes-table, echo=FALSE}
aes_vals <- data.frame(aes = c("`x`", "`y`", "`shape`",
                               "`color`", "`fill`", "`size`",
                               "`alpha`", "`linetype`"),
                       desc = c("Position on x-axis", 
                                "Position on y-axis", 
                                "Shape",
                                "Color of border of elements", 
                                "Color of inside of elements",
                                "Size", 
                                "Transparency (1: opaque; 0: transparent)",
                                "Type of line (e.g., solid, dashed)"))
knitr::kable(aes_vals, 
             col.names = c("Code", "Description"), 
             caption = "Common Plot Aesthetics")
```

## Adding geoms

When creating plots, you'll often want to add more than one `geom` to the plot.
You can add these with `+` after the `ggplot()` statement to initialize the
`ggplot2` object. Some of the most common geoms are:

```{r geom-table, echo=FALSE}
plot_funcs <- data.frame(type = c("Histogram (1 numeric variable)",
                                  "Scatterplot (2 numeric variables)",
                                  "Boxplot (1 numeric variable, possibly 1 factor variable)",
                                  "Line graph (2 numeric variables)"), 
                         ggplot2_func = c("`geom_histogram()`",
                                          "`geom_point()`",
                                          "`geom_boxplot()`",
                                          "`geom_line()`"))
knitr::kable(plot_funcs, 
             col.names = c("Plot type", "ggplot2 function"),
             caption = "Common Plot Aesthetics")
```

### Aesthetic override: a warning

The `ggplot2` package, like many `tidyverse` packages, is both flexible and
forgiving, designed to accommodate the user by "filling in the blanks" when no
information is provided. For example, in the `ggplot()` call that created
Figure \@ref(fig:mpg-fill), we didn't specify the colors to be used or the
contents of the legend; instead, `ggplot2` figured those out for us. The
`ggplot2` package is also somewhat *flexible* in how calls and aesthetic
mappings can be structured. For example, the following four calls all produce
the same (identical) plot as shown in Figure \@ref(fig:mpg-fill). Try it for
yourself.

```{r mpg-comp, eval=FALSE, message=FALSE}
# call to ggplot() with aes() specified in main call
ggplot(data = mpg, aes(x = class, fill = drv)) +
geom_bar()

# call to ggplot() with aes() specified in geom
ggplot(data = mpg) +
geom_bar(aes(x = class, fill = drv))

# call to ggplot() with a mix of aes() mappings 
ggplot(data = mpg, aes(x = class)) +
geom_bar(aes(fill = drv))

# call to ggplot() with all mappings in the geom 
ggplot() +
geom_bar(data = mpg, aes(x = class, fill = drv))
```

This flexibility also comes with occasional confusion, as you can often
***override*** one mapping with another one later on in the same call. For
example, see what happens when two different `fill` mappings are specified at
different points in the call:

```{r mpg-green, warning=FALSE, message=FALSE, fig.cap="Example of a call to `ggplot` showing counts of vehicle classes from the `mpg` dataframe and colored by the `fill` aesthetic mapped to drive type (`drv`)."}

# call to ggplot where one `fill` overrides another
ggplot(data = mpg, aes(x = class, fill = drv)) +
  geom_bar(fill = "darkgreen")
```

In this case, the aesthetic mapping of `aes(fill = drv)` was overridden by the
specification in `geom_bar()`, where we wrote `fill = "darkgreen"`. This second
specification essentially wiped away the stacked bar colors and the legend, as
shown in Figure \@ref(fig:mpg-fill). As your `ggplot2` objects become more
customized this sort of issue can arise; it comes with the territory of having
flexible code. 

## Shapes and colors

In R, you can specify the shape of points with a number. Figure \@ref(fig:shape-examples) shows the shapes that correspond to the numbers 1 to
25 in the `shape` aesthetic. This figure also provides an example of the
difference between color (black for all these example points) and fill (red for
these examples). You can see that some point shapes include a fill (21 for
example), while some are either empty (1) or solid (19).

```{r shape-examples, echo=FALSE, fig.width=5, fig.height=3, fig.align="center", fig.cap="Examples of the shapes corresponding to different numeric choices for the `shape` aesthetic. For all examples, `color` is set to black and `fill` to red."}
x <- rep(1:5, 5)
y <- rep(1:5, each = 5)
my.shapes <- 1:25
to_plot <- tibble(x = x, y = y, shape = my.shapes)
ggplot(to_plot, aes(x = x, y = y)) + 
  geom_point(shape = my.shapes, size = 4, color = "black", fill = "red") + 
  geom_text(label = my.shapes, nudge_x = -0.25) +
  xlim(c(0.5, 5.5)) + 
  theme_void() + 
  scale_y_reverse()
```

If you want to set color to be a constant value, you can do that in R using
character strings for different colors. Figure \@ref(fig:color-examples) gives
an example of some of the different blues available in R. To find links to
listings of different R colors, look up "R colors" and search by "Images".

```{r color-examples, echo=FALSE, fig.width=5, fig.height=3, fig.align="center", fig.cap="Example of available shades of blue in R."}
x <- rep(0, 6)
y <- 1:6
my.colors <- c("blue", "blue4", "darkorchid", 
               "deepskyblue2", "steelblue1", "dodgerblue3")
to_plot <- tibble(x = x, y = y, color = my.colors)
ggplot(to_plot, aes(x = x, y = y)) + 
  geom_point(color = my.colors, size = 2) + 
  geom_text(label = my.colors, hjust = 0, nudge_x = 0.05) + 
  theme_void() + 
  xlim(c(-1, 1.5)) +
  scale_y_reverse()
```

## Scales: useful plot edits

The `ggplot2` package uses ***scales*** as a way to make all sorts of tweaks
and changes to how the plot is presented. According to the `ggplot2`
documentation: 

> "Scales control the details of how data values are translated to visual properties. Override the default scales to tweak details like the axis labels or legend keys, or to use a completely different translation from data to aesthetic."

There are many scale elements that you can add onto a `ggplot2` object using
`+`. A few that are used very frequently are: 

```{r scale-elements, echo=FALSE}
plot_adds <- data.frame(add = c("`ggtitle()`",
                                "`xlab()`, `ylab()`",
                                "`xlim()`, `ylim()`",
                                "`scale_x_log10()`"),
                        descrip = c("Plot title",
                                    "Labels for x- and y-axis",
                                    "Limits of x- and y-axis",
                                    "Log scale of x-axis"))
knitr::kable(plot_adds, 
             col.names = c("Element", "Description"),
             caption = "Common Scale Elements")
```

## Example plot

For the example plots, we will continue to use the `mpg` dataset from the
`ggplot2` package. We will use functions from the `dplyr` package, too, so both
need to be loaded. Fortunately, the `ggplot2` package is loaded in addition to regualr `tidyverse` packages when you call `library(tidyverse)`. 

In this figure, we will look at highway fuel efficiency for SUVs in 2008,
ordered by manufacturer and colored by the engine displacement size in liters.
We create subsets of the `mpg` dataframe in two ways:  

1. We create a summary dataframe (`mpg_subset`) by applying two `filter()`
calls on the `mpg` object.  We then `group_by()` the manufacturer so that
average values for highway fuel economy (`hwy_mean`) and engine displacement
(`displ_mean`) can be calculated through a call to `summarize()`.  

2. We subset the `mpg` dataframe again, this time directly within the `data =`
call for `ggplot()`.   

* The first layer (`geom_jitter()`) is a point plot that adds a slight amount
of "wobble" or "jitter" to the data points so that they don't overlap on the
plot. Here, we have called `geom_jitter()` to display the individual values for
2008 SUV fuel economy on the highway as a function of manufacturer.

* The second layer (`geom_errorbar()`) is a horizontal line plot showing the
mean values for SUV models within each manufacturer.

We also add custom lables and a color scale to investigate whether engine
displacement has an effect on fuel efficiency. Note the additional aesthetic
calls for `color = ` in each layer. The final part of the call in
`theme_classic()` tells `ggplot()` to remove the gray background and the grid
lines, which are neither necessary nor visually appealing.

```{r mpg-custom-plot, message=FALSE, warning=FALSE, fig.cap="A two-layer (two `geom`) plot with customization"}

# load required R packages - alternatively, use `library(tidyverse)`, if you will need multiple tidyverse packages
library(dplyr) # for data wrangling and manipulation
library(ggplot2) # for data visualization

# use dplyr to create a summary subset from the `mpg` dataframe
mpg_subset <- mpg %>%
  dplyr::filter(class == "suv", year == 2008) %>%
  dplyr::group_by(manufacturer) %>%
  dplyr::summarize(hwy_mean = mean(hwy), displ_mean = mean(displ))

# call to ggplot, note that data and aesthetics are called in each geom layer
ggplot() +
  # first layer
  geom_jitter(data = filter(mpg, class == "suv", year == 2008),
           aes(x = manufacturer, 
               y = hwy, 
               color = displ),
           width = 0.1,
           size = 2) +
  # second layer
  geom_errorbar(data = mpg_subset,
             aes(x = manufacturer,
                 ymin = hwy_mean,
                 ymax = hwy_mean,
                 color = displ_mean),
             alpha = 0.5,
             size = 1) +
  # customize plot labels
  labs(title = "Fuel Economy for 2008 SUVs by Manufacturer and Engine Displacement",
       color = "Disp (L)") +
  ylab("highway fuel economy (miles/gal)") +
  # add a fancy color scale
  scale_color_viridis_c(option = "D", direction = -1) +
  # adopt a theme without gray background
  theme_classic() 
```

What conclusions can you draw from examining Figure \@ref(fig:mpg-custom-plot)?

In general, model year 2008 SUVs did not have great fuel economy, evidenced by
both the means and the individual data points.  

## Store and save `ggplot2` objects

Sometimes you will want to store a ggplot2 plot as an object in your global
environment, so that it can be called or manipulated later. This is done in the
same way as you would create and assign a name to any other object in R. But 
remember to **use descriptive plot names** following the naming advice from
Chapter 3 (i.e., meaningful words; lowercase; underscore as separator). In the 
following example, `plot1` does not follow this advice!

```{r ggplot-save, eval=FALSE, message=FALSE, warning=FALSE}
# create a ggplot object called "plot1"
plot1 <- ggplot(data = mpg, aes(x = class)) +
  geom_bar()
```

```{block type="rmdnote"}
When you create and store a `ggplot()` object, the plot itself will be created
and stored but not returned as output.If you want to "see" the plot, just
enter its name into the console or script.
```

You can also save `ggplot2` plots as image files to a local directory using the
`ggsave()` function.  This function requires a file name but also allows you to
specify parameters including image resolution (`dpi = 300`), image type 
(`device = png()`), and image `height`, `width` and `units` of measurement. 

```{r save-ggplot, eval=FALSE, message=FALSE, warning=FALSE}
# create a ggplot object called "plot1"
plot1 <- ggplot(data = mpg, aes(x = class)) +
  geom_bar()

ggsave("images/mpg-bar.png",
       plot = plot1,
       dpi = 150,
       device = png(),
       width = 20,
       units = "cm")
```

## Getting help with ggplot2

The `ggplot2` package has become so popular that most of my "how do I do this?"
questions have already been asked, answered, and archived on sites like
[Stack Overflow](https://stackoverflow.com/). 

Another great source is the
`ggplot2` reference section on the [tidyverse site](https://ggplot2.tidyverse.org/reference/index.html). This page contains a
nice, concise summary of how to call and customize plot objects. I recommend 
starting there because (1) it is created and maintained by the `ggplot2`
developers (and, thus, is authoritative) and (2) the reference page contains
all the function calls in an organized list, for which you can conduct a
'control/command F' search. You can also print this RStudio `ggplot2` cheat
[sheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf)
to reference while coding.

If you would like some hands-on training in `ggplot2`, look for tutorials or
webinars like [this one]() from Dr. Samantha Tyner, the creator and maintainer
of `geomnet`, a `ggplot2` extension. Speaking of which, the R community has
created a large number of `ggplot2` extensions for different data visualization
needs. If you are thinking about a custom `ggplot` style, it probably
already exists! Before building your own (which is sometimes necessary and/or
fun), take a look at this [compilation](https://exts.ggplot2.tidyverse.org/) of
`ggplot2` extensions.

## Class Exercises

Using built-in dataset

1. Create a `geom_col()`
2. Create a `geom_jitter()` (mtcars y=mpg, x=cyl)
3. Vary fill, color, line for whole plot
4. Create fill, color aesthetics

## Homework

- R Markdown template with data import, wrangling, basic plotting
