# Appendix: Reference Distributions {#dist}
In this chapter I discuss a handful of reference distributions that you may encounter while working thorugh this course. I don't go into great detail on any of these distributions (or their mathematical structure) because smarter, better, and more authoritative descriptions can be found elsehwere in reference texts or online. This is the $1 tour.  

```{r dist1, include=FALSE}
library(tidyverse)
library(gridExtra)
library(grid)
library(broom)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Uniform Distribution {#unif_dist}
The uniform distribution describes a situation where all obervations have an equal probability of occurrence. Examples of uniform distributions include: the outcome of a single  roll of a 6-sided die, or the flip of a coin, or the chance of picking a spade, heart, diamond, or club from a well-shuffled deck of cards.  In each of these cases, all potential outcomes have an equal chance of occuring.  A uniform distribition may be specified simply by setting the range of possible outcomes (i.e., a minimum, maximum, and anything in between). The "in-between" part also lets you specify whether you want to allow outcome values that are continuous (like from a random-number generator), integers (like from a dice roll), or some other format (like a binary 0 or 1; heads or tails).  

Below, we create a [probability density function](#pdf)  for the first roll of a six-sided die; this is a *discrete uniform distribition* since we only allow integers to occur.  A uniform distribution is appropriate here because any of the numbers between 1 and 6 has equal probability of being rolled.  Notice the shape of the histogram...flat.

``` {r unif-dist, fig.cap = "Outcome probability for the first roll of a 6-sided die"}
#create a uniform distribition for the first roll of a 6-sided die
six_sided <- tibble(
  rolls = ceiling(runif(10e4, min=1, max=7))
)

#create a histogram of the probability density for a uniform distribution 
ggplot(data = six_sided, aes(x = rolls)) +
  geom_histogram(
      breaks = seq(1,7,1), 
      fill = "grey",
      color = "white") +
  xlab("Number") +
  scale_x_continuous(breaks = c(0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5),
                     labels = as.factor(seq(0,6,1))) +
  theme_bw(base_size = 12)
```
  
  
### Characteristic Plots: Uniform Distribution
Below, we show the cumulative distribution plot and probability density function for a uniform distribution between 0 and 1.
``` {r unif-dist-plots2, echo=FALSE, fig.cap="Characteristic Plots for a Uniform Distribution"}
unif_dist2<-tibble(data = seq(0,1,0.001), 
                  quant = seq(0,1,0.001))
                  

unif_cdf <- ggplot(data = unif_dist2) +
  geom_point(aes(x=quant, y = data)) +
  labs(title = "Uniform Cumulative Distribution",
       y ="Cumlative Fraction",
       x = "Values")

unif_hist <- ggplot(data = unif_dist2) +
  stat_density(aes(x = data),
                 outline.type = "full",
               kernel = "gaussian",
               n = 4096,
               alpha = 0.75,
               bw = .001) +
  labs(title = "Uniform Probability Density",
       y = "Probability",
       x = "Values")

grid.arrange(unif_cdf, unif_hist, ncol=2)

```

## Normal Distribution {#normal_dist}
The normal distribution arises from phenomena that tend to have *additive* variability. By "additive", I mean that the outcome (or variable of interest) tends to vary in a +/- fashion from one observation to the next. Lots of things have additive variability: the heights of 1^st^ graders, the size of pollen grains from a tree or plant, the variation in blood pressure across the population, or the average temperature in Fort Collins, CO for the month of June.  

Let's examine what *additive variability* looks like using the 6-sided dice mentioned above.  Although a dice roll has a uniform distribution of possible outcomes (rolling a 1,2,3,4,5, or 6), the variability associated with adding up the sum of three or more dice creates a normal distribution of outcomes.  If we were to roll four, 6-sided dice and sum the result (getting a value between 4 and 24 for each roll), and then repeat this experiment 10,000 times, we see the distribution shown below.  The smooth line represents a fit using a normal distribution - a pretty nice fit considering that we are working with a discrete (integer-based) dataset!
``` {r normal1, message=FALSE, echo=FALSE, fig.cap="A Normal Distribution"}
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>% 
                         ceiling() %>% 
                         sum() #sum the result
                       ))
ggplot(data = four_dice) +
  geom_histogram(aes(x = sum, after_stat(density)),
                 bins = 21,
                 fill = "navy",
                 color = "white") + 
  stat_function(fun = dnorm, n = 101, 
                args = list(
                  mean = mean(four_dice$sum), 
                  sd = sd(four_dice$sum)
                  )
                ) +
  xlab("Sum of four, 6-sided dice") +
  theme_bw()

```

### Normal Distribution: Characteristic Plots

Unlike the uniform distribution, the normal distribution is not specified by a range (it doesn't have one).  The normal distribution is specified by a *central tendancy* (a most-common value) and a measure of data's *dispersion* or spread (a standard deviation). A normal distribution is symmetric, meaning that the spread of the data is equal on each side of the central tendency.  This symmetry also means that the mode (the most common value), the median (the 50^th^ percentile or 0.5 quantile) and the mean (the average value) are all equal. A series of normal distributions of varying dispersion is shown in the panels below.

``` {r normal2, warning=FALSE, echo=FALSE, fig.width=6, fig.height=6, fig.align="center", fig.cap="Characteristic Plots for a Normal Distribution"}
norm2 <- tibble(a = rnorm(n = 20000, mean = 50, sd = 5),
                b = rnorm(n = 20000, mean = 50, sd = 10),
                c = rnorm(n = 20000, mean = 50, sd = 15),
                d = rnorm(n = 20000, mean = 50, sd = 20),
                e = rnorm(n = 20000, mean = 50, sd = 25))

normal_ecdf <- ggplot(data = norm2) +
  stat_ecdf(aes(x = a, color = "sd = 5")) +
  stat_ecdf(aes(x = b, color = "sd = 10")) +
  stat_ecdf(aes(x = c, color = "sd = 15")) +
  stat_ecdf(aes(x = d, color = "sd = 20")) +
  stat_ecdf(aes(x = e, color = "sd = 25")) +
  xlim(0,100) +
  labs(title = "\"Normal\" Cumulative Distribution",
       x = "Values",
       y = "Cumulative Fraction") +
  scale_color_manual(values = c("black", "blue", "orange", "magenta", "darkgreen"), 
                     breaks=c("sd = 5","sd = 10","sd = 15", "sd = 20", "sd = 25"),
                     name = "Mean = 50") +
  theme_bw()

normal_density<- ggplot(data = norm2) +
  geom_density(aes(x = a, color = "sd = 5"),
               adjust = 2) +
  geom_density(aes(b, color = "sd = 10"),
               adjust = 2) +
  geom_density(aes(c, color = "sd = 15"),
               adjust = 2) +
  geom_density(aes(d, color = "sd = 20"),
               adjust = 2) +
  geom_density(aes(e, color = "sd = 25"),
               adjust = 2) +
  xlim(0,100) +
  labs(title = "\"Normal\" Probability Density",
       x = "Values",
       y = "Probability") +
  scale_color_manual(values = c("black", "blue", "orange", "magenta", "darkgreen"), 
                     breaks=c("sd = 5","sd = 10","sd = 15", "sd = 20", "sd = 25"),
                     name = "Mean = 50") +
  theme_bw() 

grid.arrange(normal_ecdf, normal_density, 
             nrow=2, 
             respect=TRUE, 
             heights = c(0.5, 0.5))


```

## Log-normal Distribution {#log_normal_dist}
Multiplicative variation is what gives rise to a "log-normal" distribution: a special type of skewed data.  

Let's create two normal distributions for variables 'a' and 'b':  

``` {r a-b-normal_dist, warning=FALSE}
#create two variables that are normally distributed
normal_data <- tibble(a = rnorm(n=1000, mean = 15, sd = 5),
                   b = rnorm(n=1000, mean = 10, sd = 3))
```

Individually, we know that these data are normally distributed (because we created them that way), but what does the distribution look like if we add these two variables together?

``` {r a-b-histogram, warning=FALSE, message=FALSE, fig.cap="The Sum of Two Normally Distributed Variables", fig.align="center"}
#add those variables together and you get a normal distribution
normal_data %>% mutate(c = a + b) -> normal_data

ggplot2::ggplot(data = normal_data) + 
  geom_histogram(aes(c),
                 bins = 30,
                 fill = "navy",
                 color = "white") +
  xlab("Sum of a + b") +
  theme_minimal(base_size = 12)
#ggsave("./images/hist_a_b.png", dpi = 150)
```
*Answer: still normal*.  Since all we did here was add together two normal distributions, we simply created a third (normal) distribution with more additive variability.  

What happens, however, if we multiply together a series of normally distributed variables?  
``` {r a-b-lognormal, message=FALSE, fig.cap="The Product of Three Normally Distributed Variables Multiplied Together", fig.align="center"}
#multiply together three normal variables
normal_data %>% 
  mutate(d = sample(a*b*c, 1000)) -> log_data

ggplot2::ggplot(data = log_data) + 
  geom_histogram(aes(d),
                 bins = 30,
                 fill = "orange",
                 color = "white") +
  xlab("a * b * c") +
  theme_minimal(base_size = 12) 
#ggsave("./images/hist_skew_out.png", dpi = 150)
```
*Answer: the additive variability becomes **multiplicative variability**, which leads to a skewed (in this case, log-normal) distribution.*

Multiplicative (or log-normal) variability arises when the mechanism(s)
controlling the variation of `x` are multipliers (or divisors) of `x`. Many
real-world phenomena create multiplicative variability in observed data: the
strength of a WiFi signal at different locations within a building, the
magnitude of earthquakes measured at a given position on the Earth's surface,
the size of rocks found in a section of a riverbed, or the size of particles
found in air. All of these phenomena tend to be governed by multiplicative
factors. In other words, all of these observations are controlled by mechanisms
that suggest $x = a * b * c$ not $x = a\cdot b\cdot c$.
``` {r a_b_lognormal_log_axis, eval=FALSE, echo=FALSE}
#plot the same data on a log scale (x axis)

ggplot2::ggplot(data = log_data) + 
  geom_histogram(aes(d),
                 bins = 25,
                 fill = "white",
                 color = "darkgrey") +
  theme_minimal() +
  scale_x_log10() +
  theme(text = element_text(size=20))
#ggsave("./images/hist_skew_out_logx.png", dpi = 150)
```

## Statistical Terms

### Pearson Correlation Coefficient {#pearson}
The Pearson correlation coefficient, ***r***, is a quantitative descriptor of the degree
of linear correlation between two variables (let's call them `x` and `y`).  
The Pearson correlation coefficient indicates the proportion of variation in `y` 
that can be explained by knowing `x`, when the data are paired.  If we have `n` 
paired samples of `x` and `y`, then ***r*** is:

$$r = \frac{n\sum(x_{i}y_{i})-\sum x_{i} \sum y_{i} } {\sqrt {n\sum(x_{i}^{2})-\sum(x_{i})^{2}} \cdot \sqrt {n\sum(y_{i}^{2})-\sum(y_{i})^{2}}}$$

This equation looks like a lot of work but it's really just a ratio of the 
*covariance* of `x` and `y` divided by the variance of `x` times the variance of
`y`.

``` {r corr_plots1, warning=FALSE, echo=FALSE, eval=FALSE}

corr_plots1 <- tibble(x = runif(100, 0, 100),
                      y1 = x,
                      y2 = map_dbl(x, ~ (.x*(rnorm(1, mean = 1,  sd = 0.03)) + 
                                           rnorm(1, mean = 0, sd = 2))),
                      y3 = map_dbl(x, ~ (.x*(rnorm(1, mean = 0.6,  sd = 0.2)) + 
                                           rnorm(1, mean = 15, sd = 15))),
                      y4 = runif(100, 0, 100)) %>%
  pivot_longer(y1:y4, names_to = "type") %>%
  mutate(types = as.factor(type))

levels(corr_plots1$types) <- c("Perfect Correlation", "Strong Correlation", "Moderate Correlation", "No Correlation")

cor_results <- corr_plots1 %>%
  nest(data = c(x, value, types)) %>%
  mutate(fit = map(data, ~lm(value ~ x, data = .)),
         m.summary = map(fit, glance)) %>%
  unnest(m.summary)
  

p1 <- ggplot(data = corr_plots1,
                          aes(x = x, y = value)) +
  geom_point(aes(color = types)) +
   geom_text(x = 25, y = 80, 
            data = cor_results, 
            aes(label = paste(round(r.squared, 2))),
            size = 2.5) +
  facet_wrap(facets = vars(types),
             ncol = 2) +
  theme_bw() +
  coord_fixed(ratio=1.0) +
  labs(x = "Independent Variable (x-axis)",
       y = "Dependent Variable (y-axis)") +
  theme(legend.position = "none")
  
p1 +   
 
```