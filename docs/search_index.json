[
["rprog3.html", "Chapter 6 Strings, Dates, and Tidying 6.1 Objectives 6.2 Strings 6.3 Dates and Date-times 6.4 Lubridate 6.5 Exercises", " Chapter 6 Strings, Dates, and Tidying 6.1 Objectives This Chapter is designed around the following learning objectives. Upon completing this Chapter, you should be able to: Define the meaning of “strings” and “date time” objects in R Manipulate character strings using the stringr and tidyr packages of functions Parse strings using regular expressions (regex) Describe how R stores the POSIXct date and time object internally Convert a column to a date format using functions from the lubridate package Extract information from a date object (e.g., month, year, day of week) using lubridate functions Search, organize, and visualize data that are linked to date objects Define the primary characteristics of “Tidy Data” Apply functions from the dplyr and tidyr packages to make data frames “tidy” 6.2 Strings A string is a character variable like “John”, or “blue”, or “John’s sample 8021A turned blue”. String variables are defined in R using quotes \" \" and stored as a character class; they often show up in data analysis in one of two ways: As metadata. Metadata means: “data that describe other data”. A readme.txt file is metadata; notes and code comments are metadata - all of these types of data usually come in the form of strings and are included with the data your are analyzing but not in the data set itself. As vectorized data. In R programming, “vectorized” means: stored as a column of data. Examples of vectorized string variables you might find include things like: “participant names”, or “survey responses to question 1”, or “mode of failure”. The examples below show how string variables are created in R. # examples of vectorized string data names_respond &lt;- c(&quot;Ahmed&quot;, &quot;Josh&quot;, &quot;Mateo&quot;, &quot;William&quot;, &quot;Ali&quot;, &quot;Wei&quot;, &quot;Steve-O&quot;, &quot;John&quot;) q1_responses &lt;- c(&quot;Because you told me to do it.&quot;, &quot;It seemed like the right thing to do at the time.&quot;, &quot;Because I had been over-served.&quot;, &quot;I don&#39;t know. I just did it.&quot;, &quot;I got caught up in the heat of the moment.&quot;, &quot;I was given an opportunity. I took my shot.&quot;, &quot;I plead the 5th.&quot;, &quot;I could ask you the same question.&quot;) failure_mode &lt;- c(&quot;fracture&quot;, &quot;yielding&quot;, &quot;deflection&quot;, &quot;fatigue&quot;, &quot;creep&quot;) #proof class(names_respond) ## [1] &quot;character&quot; The first step in analyzing a string is to parse it. To parse means to examine the individual components. For example, when you read this sentence you parse out the words and then assign meaning to those words based on your memory, your understanding of grammar, and the context in which those words occur (i.e., whether you are reading an instruction manual, a text message, a novel, or a warrant for your arrest). Strings can be challenging to analyze because computers are built on logical operations and mathematics; strings are neither of those. Computers have fantastic memory, are OK at grammar, and are comically poor at contextualization. Taken together, this means that strings can be challenging (but not impossible) to analyze using computers. Are you active on social media platforms like Instagram or Twitter? You can bet that a computer program has downloaded and parsed all of your posts, each one as a string. You can learn a lot about a person (and their buying habits) from what they post online! In this chapter, we will introduce a few simple string functions from {base} R and the stringr package. We will also introduce the concept of regular expressions as a means to perform more advanced string manipulation. 6.2.1 String detect, match, subset One of the simplest string operations is to search whether a string contains a pattern of interest. The stringr package (part of the Tidyverse) was developed to simplify the analysis of strings. Most of the functions in stringr begin with str_ and end with a specific function name. A full list of functions is provided here. Some examples: str_detect() returns a vector of logical values (TRUE/FALSE) indicating whether the pattern was detected within each string searched. The function takes two arguments, the string to be searched and the pattern to search for. Let’s search for the pattern \"Josh\" in the character vector of strings, names_respond, that we created above: str_detect(string = names_respond, pattern = &quot;Josh&quot;) ## [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE As expected, only one string in the vector produced a match. An added benefit of logical functions like str_detect() is that return values of TRUE are coded as 1 and FALSE as 0. Thus, if we sum() the result of the str_detect() search, we will get the cumulative number of matches to \"Josh\" from within our data. str_detect(string = names_respond, pattern = &quot;Josh&quot;) %&gt;% sum() ## [1] 1 In other words, logical functions like str_detect() allow us to do math on string data! For example, we can now calculate the proportion of \"Josh\" entries within our sample: str_detect(string = names_respond, pattern = &quot;Josh&quot;) %&gt;% sum() / length(names_respond) ## [1] 0.125 str_extract() takes the same arguments as str_detect() but returns a vector of the matched values (by string index). By “matched values”, I mean only the portion of the string for which the search created a match. str_extract(string = names_respond, pattern = &quot;Jo&quot;) ## [1] NA &quot;Jo&quot; NA NA NA NA NA &quot;Jo&quot; str_subset() returns only the entries that were matched (i.e., if a match was detected, then the entire string that was matched is returned). If we subset our short list of names to the pattern of letters \"li\", we get: str_subset(string = names_respond, pattern = &quot;li&quot;) ## [1] &quot;William&quot; &quot;Ali&quot; To note, there are {base} R versions of all these stringr functions. Most are performed with the grep family of functions. The term “grep” is an acronym for Global Regular Expression Pattern (more on regular expressions below). Many of “old-school” coders use this family of functions (meaning: you will encounter them in the wild), so it’s worth mentioning them. stringr_funcs base_funcs str_detect(x, pattern) grepl(pattern, x) str_match(x, pattern) regexec(pattern, x) + regmatches() str_subset(x, pattern) grep(pattern, x, value = TRUE) 6.2.2 Regular Expressions Before going much farther, we should spend some time discussing regular expressions or regex for short. When we pass a pattern argument to a function like str_detect(), the function treats that argument like a “regex”. Up until this point, I have only passed simple character strings as pattern arguments (i.e., pattern = \"Josh\"). In reality, we can create much more advanced search criteria using regex syntax within our search patterns. A regular expression is a sequence of characters that define a search pattern to be implemented on a string. Regex sequences allow for pattern searching with logical and conditional relations, for example, the following text search patterns can be coded as regex: “any letter followed by the numbers 3, 4, or 5” … [:alpha:][345] “strings beginning with the letters ‘ID’ and followed by four numbers” … ^ID[:digit:]{4} In the R programming language, regular expressions follow the POSIX 1003.2 standard (regex can have different syntax based on the underlying standard). Regex are created by including search syntax (i.e., symbols that communicate search parameters) within your quoted string. For example, square brackets around a string [] indicate a search for any of the characters within the brackets (conversely, to match all the characters you simply include them in quotes). To search for any digit or whitespace, you would add a \\d or a \\s to the regex, respectively. One challenging aspect of string searching in R, however, is that certain “special characters” like the quote \" and the backslash \\ symbol must be explicitly identified within string in order to be interpreted by R correctly. To identify these special characters in a string, you need to “escape” that character using a second backslash \\. In other words, whenever a regex requires the use of a \\, you have to identify it within a string as \\\\. Or, if you want to search for a quote symbol, you would type in \\\". The table below shows some basic regex syntax and how they would be implemented in an R string. Table 6.1: Basic Regex Search Syntax and Example Implementation in R Regex syntax String to be matched Example in R \\d Any digit “\\\\d” [abc] matches a, b, or c “[abc]” [a-z] matches every character between a and z “[a-z]” [^abc] matches anything except a, b, or c “[^abc]” (abc) creates a “capture group” whereby abc must occur together “(abc)” ^b look for “b” at the start of a string “^b” $b look for “b” at the end of a string “$b” a|b match a or b “a|b” Regex sequences have seemingly no end of sophistication and nuance; you could spend dozens of hours learning to use them and hundreds more learning to master them. We will only introduce basic concepts here. More in-depth introductions to regex syntax and usage can be found on H. Wickham’s R course, on the stringr cheatsheet developed by RStudio, and through practice with, my personal favorite, a game of Regex Golf. 6.2.3 String split, replace str_split() will split a string into two (or more) pieces when a match is detected. The string will always be split at the first match and again at each additional match location, unless you specify that only a finite number of n matches should occur. Note, the string is split on each side of the match, which itself is not included in the output. str_split(string = names_respond, pattern = &quot;t&quot;) ## [[1]] ## [1] &quot;Ahmed&quot; ## ## [[2]] ## [1] &quot;Josh&quot; ## ## [[3]] ## [1] &quot;Ma&quot; &quot;eo&quot; ## ## [[4]] ## [1] &quot;William&quot; ## ## [[5]] ## [1] &quot;Ali&quot; ## ## [[6]] ## [1] &quot;Wei&quot; ## ## [[7]] ## [1] &quot;S&quot; &quot;eve-O&quot; ## ## [[8]] ## [1] &quot;John&quot; str_replace() searches for a match and then replaces the matched value with a new string of your choosing. The function takes three arguments: the string to be searched, the pattern to match, and the replacement string to be inserted. Let’s replace all the periods in q1_responses with question marks. To do so requires us to “escape” each symbol with two backslashes \\\\ since these are special characters. str_replace(string = q1_responses, pattern = &quot;\\\\.+&quot;, replacement = &quot;\\\\?&quot;) ## [1] &quot;Because you told me to do it?&quot; ## [2] &quot;It seemed like the right thing to do at the time?&quot; ## [3] &quot;Because I had been over-served?&quot; ## [4] &quot;I don&#39;t know? I just did it.&quot; ## [5] &quot;I got caught up in the heat of the moment?&quot; ## [6] &quot;I was given an opportunity? I took my shot.&quot; ## [7] &quot;I plead the 5th?&quot; ## [8] &quot;I could ask you the same question?&quot; Note that str_replace() 6.3 Dates and Date-times To begin, we discuss how {base} R code handles dates and times, since there is a ton of code out there that utilizes these older functions. We will then quickly transition to the lubridate family of functions (part of the Tidyverse) because of their versatility and ease-of-use. 6.3.1 Dates and Times in base R Dates and times in base R all proceed from an “epoch” or time origin. In R, the epoch or “dawn of time” occurred at midnight on January 1st, 1970. For the sake of the R programming world, the concept of time started at that precise moment and has moved forward ever since. To note: R can handle date-times before 1/1/1970; it just treats them as negative values! To see a date-time object, you can tell R to give you the current “System Time” by calling the Sys.time() function. Sys.time() ## [1] &quot;2020-08-05 12:19:41 MDT&quot; As you can see, we got back the date, time, and current timezone used by my computer. If you want to see how this time is stored in R internally, you can use unclass(), which returns an object value with its class attributes removed. When we wrap unclass() around Sys.time(), we will see the number of seconds that have occurred between the epoch of 1/1/1970 and right now: unclass(Sys.time()) ## [1] 1596651582 That’s a lot of seconds. How many years is that? Just divide that number by [60s/min \\(\\cdot\\) 60min/hr \\(\\cdot\\) 24hr/d \\(\\cdot\\) 365d/yr] ~ 50.6294895 years. This calculation ignores leap years but you get the point… 6.3.2 Date-time formats Note that the Sys.time() function provided the date in a “year-month-day” format and the time in an “hour-minute-second” format: 2020-08-05 12:19:41 Not everyone uses this exact ordering when they record dates and times, which is one of the reasons working with dates and times can be tricky. You probably have little difficulty recognizing the following date-time objects as equivalent but not-so-much for some computer programs: Table 6.2: Date-time objects come in different forms 12/1/99 8:46 PM 1-Dec-1999 20: UTC December 1st, 1999, 20:46:00 You will often see time referenced with a “UTC”, which stands for “Universal Time, Coordinated”. UTC is preferred by programmers because it doesn’t have a timezone and it doesn’t follow Daylight Savings Time conventions (daylight savings is the bane of many coders). In practice, UTC is the same time as GMT (Greenwich Mean Time, pronounced “gren-itch”) but with an important distinction. GMT is one of the many time-zones laid out across Earth’s longitude, whereas, UTC has no time zone. 6.3.3 Date-time classes in R R has several classes of date-time objects, none of which are easy to remember: POSIXct - stored as the time, in seconds, between the epoch of 1970-01-01 00:00:00 UTC and the date-time object in question. the ‘ct’ stands for “continuous time” to represent “continuous seconds from origin”; A POSIXct object is a single numeric vector (and so provides for efficient computing). POSIXlt - stored as a list of date-time objects. the ‘lt’ stands for “list time”. A POSIXlt list contains the following elements: sec as 0–61 seconds min as 0–59 minutes hour as 0–23 hours mday as 1–31 day of the month mon as 0–11 months after the first of the year year as Years since 1900 wday as 0–6 day of the week, starting on Sunday yday as 0–365 days of the year. isdst as a flag for Daylight savings time. Positive if in force, zero if not, negative if unknown. POSIXt - this is a virtual class. POSIXt (without the “l”) is an internal way for R to convert between POSIXct and POSIXlt date-time objects. Think of the POSIXt as a way for R to perform operations/conversions between a POSIXct and POSIXlt object without throwing an error your way. As a reminder, here are some of the most common vector classes in R: Class Example character “Chemistry”, “Physics”, “Mathematics” numeric 10, 20, 30, 40 factor Male [underlying number: 1], Female [2] Date “2010-01-01” [underlying number: 14,610] logical TRUE, FALSE date-time “2020-06-23 11:05:20 MDT” To discover the class of a vector (including a column in a dataframe – remember each column can be thought of as a vector), you can use class(): class(Sys.time()) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; Both the POSIXct and POSIXlt class of objects return the same value to the user; the difference is really in how these classes store date-time objects internally. To examine them, you can coerce Sys.time() into each of the two classes using as.POSIXct and as.POSIXlt functions and then examine their attributes. time_now_ct &lt;- as.POSIXct(Sys.time()) unclass(time_now_ct) ## [1] 1596651582 time_now_lt &lt;- as.POSIXlt(Sys.time()) str(unclass(time_now_lt)) # the `str()` function makes the output more compact ## List of 11 ## $ sec : num 41.7 ## $ min : int 19 ## $ hour : int 12 ## $ mday : int 5 ## $ mon : int 7 ## $ year : int 120 ## $ wday : int 3 ## $ yday : int 217 ## $ isdst : int 1 ## $ zone : chr &quot;MDT&quot; ## $ gmtoff: int -21600 ## - attr(*, &quot;tzone&quot;)= chr [1:3] &quot;&quot; &quot;MST&quot; &quot;MDT&quot; It’s easy to see why the POSIXct object class is more computationally efficient; but it’s also nice to see all the date-time information packed into the POSIXlt. This is why R keeps a key to unlock both using POSIXt. As my father used to say: clear as mud? 6.3.4 Reading and classifying date-times Oftentimes, when data is read into R, there are column elements that contain date and time information. These dates and times are often interpreted by R as character vectors, which means they have lost their relational attributes (i.e., you cannot subtract “Monday 08:00” from “Wednesday 12:00” and get “2 days 4 hours”). If we want to analyze dates and times in a relational way, we need to instruct R to recognize these as date-time objects (i.e., as either the POSIXct or POSIXlt class). Thus, to convert a character vector into date or date-time object requires a change of that vector’s class. Date-time elements can be tricky to work with for a few reasons: Different programs store and handle dates and times in different ways The existence of time zones means that date-time values can change with location Date-time strings can be separated with spaces, colons, commas, slashes, dashes, or a mix of all those together (see Table 6.2) The {base} R function to convert between character classes and date-time classes is the function strptime(), which is short for “string parse into date-time”. I mention this function not because I encourage you to use it but because I want you to be able to recognize it. The function has over 39 conversion specifications that it can take as arguments. That is to say, this function not simple to master. If you are a glutton for punishment, I invite you to read the R Documentation ?strptime. In summary here are a few {base} R functions on date-time object that are worth knowing: Table 6.3: Basic Date-time functions {base} R Function Value Returned Example Sys.Date() Current system date “2020-06-23” Sys.time() Current system date-Time “2020-06-23 11:05:20 MDT” Sys.timezone() Current system timezone “America/Denver” as.POSIXct() date-time object of class POSIXct “2020-06-23 11:05:20 MDT” as.POSIXlt() date-time object of class POSIXlt “2020-06-23 11:05:20 MDT” strptime() date-time object of class POSIXlt “2020-06-23 11:05:20 MDT” 6.4 Lubridate The lubridate package was developed specifically to make life easier when working with date-time objects. You can find out more information on lubridate here. 6.4.1 Lubridate Parsing Functions One of best aspects of lubridate is its ability to parse date-time objects with simplicity and ease; the lubridate parsing functions are designed as “named-to-order”. Let me explain: Parse: to break apart and analyze the individual components (of something, like a character string) If a character vector is written in “year-month-day” format (i.e., \"2020-Dec-18\"), then the lubridate function to convert that vector is ymd(). If a character vector is written in “day-month-year” format (i.e., \"18-Dec-2020\"), then the lubridate function to convert that vector is dmy(). Try it out: #create a character vector date_old &lt;- &quot;2020-Dec-18&quot; #prove to yourself it&#39;s a character class class(date_old) ## [1] &quot;character&quot; #convert it to a `Date` class with `ymd()` date_new &lt;- ymd(date_old) #prove to yourself it worked class(date_new) ## [1] &quot;Date&quot; That little conversion exercise may not have blown you away, but watch what happens when I feed the following set of wacky character vectors into that same lubridate parsing function, ymd(): messy_dates &lt;- c(&quot;2020------Dec the 12&quot;, &quot;20.-.12.-.12&quot;, &quot;2020aaa12aaa12&quot;, &quot;20,12,12&quot;, &quot;2020x12-12&quot;, &quot;2020 .... 12 ...... 12&quot;, &quot;&#39;20.December-12&quot;) ymd(messy_dates) ## [1] &quot;2020-12-12&quot; &quot;2020-12-12&quot; &quot;2020-12-12&quot; &quot;2020-12-12&quot; &quot;2020-12-12&quot; ## [6] &quot;2020-12-12&quot; &quot;2020-12-12&quot; That’s right. The ymd() parsing function figured them all out correctly with almost no effort on your part. But wait, there’s more! The lubridate package contains parsing functions for almost any order you can dream up. Parsing Function Format to Convert ymd() year-month-day mdy() month-day-year dmy() day-month-year And if you need to parse a time component, simply add a combination of _hms to the function call to parse time in “hours-minutes-seconds” format. Some additional examples of how you would parse time that followed from a ymd format: Parsing Function Format to Convert ymd_h() year-month-day_hours mdy_hm() year-month-day_hours-minutes dmy_hms() year-month-day_hours-minutes-seconds The beauty of the lubridate parsers is that they do the hard work of cleaning up the character vector, regardless of separators or delimiters within each string, and return either a Date or Date-time object class. 6.4.2 Date-time manipulation with Lubridate To convert the date column in the daily_show data into a Date class, then, you can run: library(package = &quot;lubridate&quot;) class(x = daily_show$date) # Check the class of the &#39;date&#39; column before mutating it ## [1] &quot;character&quot; daily_show &lt;- mutate(.data = daily_show, date = mdy(date)) head(x = daily_show, n = 3) ## # A tibble: 3 x 5 ## year job date category guest_name ## &lt;dbl&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1999 actor 1999-01-11 Acting Michael J. Fox ## 2 1999 Comedian 1999-01-12 Comedy Sandra Bernhard ## 3 1999 television actress 1999-01-13 Acting Tracey Ullman class(x = daily_show$date) # Check the class of the &#39;date&#39; column after mutating it ## [1] &quot;Date&quot; Once you have an object in the Date class, you can do things like plot by date, calculate the range of dates, and calculate the total number of days the dataset covers: # report the min and max dates range(daily_show$date) # calculate the duration from first to last date diff(x = range(daily_show$date)) We could have used these to transform the date in daily_show, using the following pipe chain: daily_show &lt;- read_csv(file = &quot;data/daily_show_guests.csv&quot;, skip = 4) %&gt;% rename(job = GoogleKnowlege_Occupation, date = Show, category = Group, guest_name = Raw_Guest_List) %&gt;% select(-YEAR) %&gt;% mutate(date = mdy(date)) %&gt;% filter(category == &quot;Science&quot;) head(x = daily_show, n = 2) ## # A tibble: 2 x 4 ## job date category guest_name ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; ## 1 neurosurgeon 2003-04-28 Science Dr Sanjay Gupta ## 2 scientist 2004-01-13 Science Catherine Weitz The lubridate package also includes functions to pull out certain elements of a date, including: wday() return the day of the week pertaining to a Date object mday() return the day of the month pertaining to a Date object yday() return the day of the year pertaining to a Date object month() return the month pertaining to a Date object quarter() return the quarter of hte year pertaining to a Date object year() return the year pertaining to a date object For example, we could use wday() to create a new column with the weekday of each show: mutate(.data = daily_show, show_day = wday(x = date, label = TRUE)) %&gt;% select(date, show_day, guest_name) %&gt;% slice(1:5) ## # A tibble: 5 x 3 ## date show_day guest_name ## &lt;date&gt; &lt;ord&gt; &lt;chr&gt; ## 1 2003-04-28 Mon Dr Sanjay Gupta ## 2 2004-01-13 Tue Catherine Weitz ## 3 2004-06-15 Tue Hassan Ibrahim ## 4 2005-09-06 Tue Dr. Marc Siegel ## 5 2006-02-13 Mon Astronaut Mike Mullane R functions tend to use the timezone of YOUR computer’s operating system by default, or UTC, or GMT. You need to be careful when working with dates and times to either specify the time zone or convince yourself the default behavior works for your application. 6.5 Exercises Provide link to "]
]
