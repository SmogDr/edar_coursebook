alpha = 0.25,
color= "royalblue2") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 1)
p5 <- ggplot(data = model1$model) +
geom_point(aes(x = model1$fitted.values, y =model1$residuals),
alpha = 0.25,
color = "maroon3") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 1)
p6 <- ggplot(data = model2$model)+
geom_point(aes(x = model2$fitted.values, y =model2$residuals),
alpha = 0.25,
color= "royalblue2") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 1)
grid.arrange(p5, p6, ncol = 2)
p5 <- ggplot(data = model1$model) +
geom_point(aes(x = model1$fitted.values, y =model1$residuals),
alpha = 0.25,
color = "maroon3") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 0.5)
p6 <- ggplot(data = model2$model)+
geom_point(aes(x = model2$fitted.values, y =model2$residuals),
alpha = 0.25,
color= "royalblue2") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 0.5)
grid.arrange(p5, p6, ncol = 1)
acf(model1$residuals)
pacf(model1$residuals)
pacf(model2$residuals)
pacf(model1$residuals)
pacf(model2$residuals)
stats::pacf(model1$residuals, main = "Model 1")
stats::pacf(model2$residuals)
stats::pacf(model1$residuals, main = "Model 1")
stats::pacf(model2$residuals)
stats::pacf(model1$residuals,
main = "Model 1 Partial Autocorrelation Plot")
stats::pacf(model2$residuals,
main = "Model 2 Partial Autocorrelation Plot")
cor(x = model1$residuals, y = model1$model[,2])
model1$model[,2]
r_m1_resid_x <- cor(x = model1$residuals,
y = model1$model[,2],
method = "Pearson" )
r_m1_resid_x <- cor(x = model1$residuals,
y = model1$model[,2],
method = "pearson" )
r_m2_resid_x <- cor(x = model2$residuals,
y = model1$model[,2],
method = "pearson" )
View(data_18)
model3 <- lm(data = data_18, formula = mass ~ height + (waist)^2)
summary(model3)
data_18 <- data_18 %>% mutate(vol = height*waist*waist)
model4 <- lm(data = data_18, formula = mass ~ vol)
summary(model4)
plot(model4)
plot(model3)
pacf(model3$residuals)
install.packages("fitdistplus")
install.packages("fitdistrplus")
library(fitdistrplus)
?fitdistrplus
descdist(data = data_18$mass)
str(data_18$mass)
descdist(data = data_18$waist)
mass2 <- as.numeric(data_18$mass)
descdist(mass2)
descdist(data = mass2)
min(mmass2)
min(mass2)
descdist(data = mass2, method = "sample")
mass2 <- mass2 %>% na.omit()
min(mass2)
descdist(data = mass2, method = "sample")
str(mass2)
descdist(data = mass2)
mass2 <- as.numeric(mass2)
descdist(data = mass2)
hist(mmass2)
hist(mass2)
hist(data_18$height)
height2 <- data_18$height %>% na.omit() %>% as.numeric()
descdist(height2)
View(data_18)
hist(data_a8$waist)
hist(data_18$waist)
waist2 <- data_18$waist %>% na.omit() %>% as.numeric()
descdist(waist2)
mass3 <- data_18$sqrt_mass %>% na.omit() %>% as.numeric()
descdist(mass3)
boxcox(mass2)
boxcox(model1)
boxcox(model2)
boxcox(model3)
boxcox(model4)
View(model4)
knitr::include_graphics("./images/cylinder_comic.png")
p1 <- ggplot(data = data_18) +
geom_point(aes(x = waist, y = mass),
alpha = 0.1,
color = "maroon4") +
ylab("Mass, kg") +
xlab("Waist Circumference, cm") +
theme_classic(base_size = 13)
p2 <- ggplot(data = data_18) +
geom_point(aes(x = waist, y = sqrt_mass),
alpha = 0.1,
color = "royalblue2") +
ylab(expression(sqrt(mass))) +
xlab("Waist Circumference, cm") +
theme_classic(base_size = 13)
grid.arrange(p1, p2, ncol = 2)
p3 <- ggplot(data  = model1$model, aes(sample = model1$residuals)) +
geom_qq(alpha = 0.1,
color = "maroon4") +
geom_qq_line(color = "grey") +
ggtitle("Model 1: mass ~ waist") +
theme_classic()
p4 <- ggplot(data  = model2$model, aes(sample = model2$residuals)) +
geom_qq(alpha = 0.1,
color = "royalblue2") +
geom_qq_line(color = "grey") +
ggtitle("Model 2: sqrt(mass) ~ waist") +
theme_classic()
grid.arrange(p3, p4, ncol = 2)
p5 <- ggplot(data = model1$model) +
geom_point(aes(x = model1$fitted.values, y =model1$residuals),
alpha = 0.25,
color = "maroon3") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 0.5)
p6 <- ggplot(data = model2$model)+
geom_point(aes(x = model2$fitted.values, y =model2$residuals),
alpha = 0.25,
color= "royalblue2") +
geom_hline(yintercept = 0) +
theme_classic() +
theme(aspect.ratio = 0.5)
grid.arrange(p5, p6, ncol = 1)
library(tidyverse)
library(lubridate)
library(knitr)
library(kableExtra)
library(scales)
# import and wrangle noaa temperature data from CO & HI July 2010
noaa_temp <- readr::read_csv("data/NOAA_temps2.csv") %>%
dplyr::rename(station = STATION,
name = NAME,
temp_hr_f = `HLY-TEMP-NORMAL`) %>%
dplyr::mutate(date = lubridate::parse_date_time(DATE, orders = "mdhms")) %>%
dplyr::mutate(location = dplyr::case_when(
stringr::str_detect(station, "23066") ~ "Colorado",
stringr::str_detect(station, "22536") ~ "Hawaii")) %>%
dplyr::select(station, location, date, temp_hr_f) # year missing from date
# plot temperature by location
noaa_temp %>%
ggplot2::ggplot(mapping = aes(x = temp_hr_f,
y = location,
color = location)) +
geom_jitter(height = 0.15,
size = 1.5,
shape = 1) +
labs(y = "Region",
x = "Temperature (°F)") +
theme_bw() +
theme(legend.position = "none") +
ggsave("./images/NOAA_temps.png", dpi = 150)
knitr::include_graphics("images/NOAA_temps.png")
# create average temperature by location
noaa_temp_avg <- noaa_temp %>%
dplyr::group_by(location) %>%
dplyr::summarize(temp_avg = mean(temp_hr_f))
knitr::include_graphics("./images/NOAA_temps_annotate.png")
# "set seed" to generate the same results each time
set.seed(1)
# create uniform distribution
univar <- runif(n = 1000, min = 0, max = 100)
# split uniform distribution into quantiles
univar_quart <- quantile(univar, probs = seq(0, 1, 0.25)) %>% round(1)
knitr::include_graphics("./images/quantile_1.png")
# create df of quantile
quant_desc <- tibble::tibble(a = c("0", "1", "0.5", "0.25",
"0.75", "0.75 - 0.25"),
b = c("minimum", "maximum", "median",
"25^th^%", "75^th^%", "IQR"),
c = c(univar_quart[[1]],
univar_quart[[5]],
univar_quart[[3]],
univar_quart[[2]],
univar_quart[[4]],
univar_quart[[4]] - univar_quart[[2]]
)
quant_desc %>%
knitr::kable(caption = "Quantiles and descriptive statistics for uniform
distribution, 0-100 (n=1000)",
booktabs = TRUE,
col.names = c("Quantile", "Descriptor", "Example Values"),
align = "c") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = F)
# "set seed" to generate the same results each time
set.seed(2)
# create normal distribution
norm_dist <- rnorm(1000, mean = 50, sd = 15)
# split normal distribution into quantiles and output tabular result
quantile(norm_dist, probs = seq(0, 1, 0.1)) %>% round(0)
# manual method for calculating quantiles
norm_manual <- tibble::tibble(
# start with raw sample data generated from `rnorm()`
sample_data = norm_dist,
# sort the data
sorted_data = sort(norm_dist),
# calculate cumulative fraction for each entry
cum_frac = seq.int(from = 1 / length(norm_dist),
to = 1,
by = 1 / length(norm_dist)))
# create deciles sequence
deciles <- seq.int(from = 0, to = 1, by = 0.1)
# extract quantiles that match the decile values created above
normal_data_deciles <- norm_manual %>%
dplyr::filter(cum_frac %in% deciles)
# randomly sample two variables from normal distributions with `rnorm()`
normal_data <- tibble::tibble(a = rnorm(n=1000, mean = 15, sd = 5),
b = rnorm(n=1000, mean = 10, sd = 3))
# create unit quantile values for the `normal_data`
normal_data_cdf <- normal_data %>%
dplyr::select(a) %>%
dplyr::arrange(a) %>%
dplyr::mutate(unit_quantiles = seq.int(from = 1/length(a),
to = 1,
by = 1/length(a)))
# plot cumulative distribution
normal_data_cdf %>%
ggplot2::ggplot(mapping = aes(x = a,
y = unit_quantiles)) +
geom_point(shape = 21,
fill = "black",
alpha = 0.25) +
labs(x = "Average Temperature (\u00B0C)",
y = "Cumulative Fraction") +
theme_minimal() +
scale_x_continuous(breaks = seq(0, 35, by = 5)) +
scale_y_continuous(breaks = seq(0, 1, by = 0.1)) +
theme(text = element_text(size=15),
axis.title.y = element_text(margin = unit(c(0, 5, 0, 0), "mm")),
axis.title.x = element_text(margin = unit(c(5, 0, 0, 0), "mm")),
aspect.ratio=3/4) +
ggsave("./images/normal_cum_dist.png", dpi = 150)
knitr::include_graphics("./images/normal_cum_dist_anno.png")
# import data; fix column names
raw_salaries <- readr::read_csv("data/ME_salaries.csv",
col_types = "iif",
col_names = c("salary", "age","gender"),
skip = 1)
# create cumulative fractions
ordered_salaries <- raw_salaries %>%
dplyr::select(salary) %>%
dplyr::filter(salary < 500000) %>% # to remove numeric identifiers
dplyr::arrange(salary) %>%
dplyr::mutate(cum_pct = seq.int(from = 1/length(salary),
to = 1,
by = 1/length(salary)))
# alternate method if you don't want to calculate cumulative fractions
ordered_salaries %>%
ggplot2::ggplot(mapping = aes(x = salary)) +
geom_step(stat = "ecdf") + # "empirical cumulative distribution function"
labs(x = "Salaries of ME Graduates", y = "Cumulative Fraction") +
scale_y_continuous(limits = c(-0.05, 1.03),
expand = c(0,0),
breaks = seq(from = 0,
to = 1,
by = 0.1)) +
scale_x_continuous(labels = scales::label_dollar(scale = 0.001,
prefix = '$',
suffix = 'k'),
minor_breaks = seq(from = 0,
to = 450000,
by = 10000))+
geom_segment(data = data.frame(x = quantile(ordered_salaries$salary),
y = rep.int(-.05, 5),
xend = quantile(ordered_salaries$salary),
yend = seq(from = 0, to = 1, by = 0.25)),
aes(x = x, y = y, xend = xend, yend = yend),
color = "red",
linetype = "dashed") +
theme_bw() +
ggsave("./images/cdf_me_salaries.png", dpi = 150)
knitr::include_graphics("./images/cdf_me_salaries.png")
# set seed to generate same results each time
set.seed(3)
# create df of 1000 observations from a normal distribution
sample_norm <- tibble::tibble(data = rnorm(10000,
mean = 30,
sd = 3))
# create histogram
sample_norm %>%
ggplot2::ggplot(mapping = aes(x = data)) +
geom_histogram(bins = 30,
fill = "white",
color = "darkgrey") +
theme_minimal() +
theme(text = element_text(size=20)) +
ggsave("./images/hist_norm.png", dpi = 150)
knitr::include_graphics("./images/hist_anno_1.png")
# set seed to generate same results each time
set.seed(4)
# create df of values from log-normal distribution
sample_lognorm <- tibble::tibble(data = round(rlnorm(5000,
meanlog = log(50),
sdlog = 1),
0))
# generate outliers
outliers <- tibble::tibble(data = rep(195, 75))
# bind lognorm and outliers in one df
skew_norm <- dplyr::bind_rows(sample_lognorm, outliers)
# plot and save skewed normal distribution
skew_norm %>%
ggplot2::ggplot(mapping = aes(x = data)) +
geom_histogram(bins = 50,
fill = "white",
color = "darkgrey") +
xlim(1, 400) +
theme_minimal() +
theme(text = element_text(size = 28)) +
ggsave("images/skew_hist_2.png",
dpi = 150, width = 9, height = 6, units = "in")
knitr::include_graphics("./images/hist_anno_2.png")
knitr::include_graphics("./images/hist_anno_3.png")
normal_data %>%
ggplot2::ggplot(mapping = aes(y = b, x = 1)) +
geom_boxplot(outlier.shape = NA, width = 0.25) +
xlab("Data Name") +
ylab("Data Values") +
xlim(c(0.5, 1.5)) +
theme_classic() +
theme(text = element_text(size=15),
axis.text.x=element_blank(),
axis.ticks.x=element_blank()) +
ggsave("./images/boxplot_1.png")
knitr::include_graphics("./images/boxplot_1_anno.png")
# boxplots to compare temperature in CO and HI
noaa_temp %>%
ggplot2::ggplot(mapping = aes(y = temp_hr_f,
x = location,
group = location)) +
geom_boxplot(mapping = aes(fill = location),
width = 0.5) +
ylab("Temperature, °F") +
xlab(NULL) +
theme_classic() +
theme(text = element_text(size=15),
legend.position = "none")
# plot temperature (y) vs time (y) for Hawaii data
noaa_temp %>%
dplyr::filter(location == "Hawaii") %>%
ggplot2::ggplot(mapping = aes(x = date,
y = temp_hr_f)) +
geom_line(linejoin = "round",
color = "purple") +
geom_point(size = 1,
shape = 1,
color = "purple") +
labs(x = "Date",
y = "Temperature, °F") +
theme_bw() +
ggsave("./images/noaa_hi_time.png", dpi = 150)
knitr::include_graphics("./images/noaa_hi_time.png")
# plot temperature (y) vs time (y) for Hawaii data for one week
noaa_temp %>%
dplyr::filter(location == "Hawaii",
date <= "0000-07-05") %>%
ggplot2::ggplot(mapping = aes(x = date,
y = temp_hr_f)) +
geom_line(linejoin = "round",
color = "purple") +
geom_point(size = 1,
shape = 1,
color = "purple") +
labs(x = "Date",
y = "Temperature, °F") +
theme_bw() +
ggsave("./images/noaa_hi_week.png", dpi = 150)
knitr::include_graphics("./images/noaa_hi_week.png")
# subset data to contain only measures from Hawaii
noaa_temp_hi <- noaa_temp %>%
dplyr::filter(location == "Hawaii")
# call the autocorrelation plot from base R `stats` package
stats::acf(noaa_temp_hi$temp_hr_f,
main = " " ,
xlab = "Lag (hours)",
ylab = "Correlation coefficient")
# create partial autocorrelation plot
stats::pacf(noaa_temp_hi$temp_hr_f,
main = " ",
xlab = "Lag (hours)",
ylab = "Partial Correlation Coefficient")
# plot cumulative distribution
normal_data_cdf %>%
ggplot2::ggplot(mapping = aes(x = a,
y = unit_quantiles)) +
geom_point(shape = 21,
fill = "black",
alpha = 0.25) +
labs(x = "Average Temperature (\u00B0C)",
y = "Cumulative Fraction") +
theme_minimal() +
scale_x_continuous(breaks = seq(0, 35, by = 5)) +
scale_y_continuous(breaks = seq(0, 1, by = 0.1)) +
theme(text = element_text(size=15),
axis.title.y = element_text(margin = unit(c(0, 5, 0, 0), "mm")),
axis.title.x = element_text(margin = unit(c(5, 0, 0, 0), "mm")),
aspect.ratio=3/4) +
ggsave("./images/normal_cum_dist.png", dpi = 150)
# alternate method if you don't want to calculate cumulative fractions
ordered_salaries %>%
ggplot2::ggplot(mapping = aes(x = salary)) +
geom_step(stat = "ecdf") + # "empirical cumulative distribution function"
labs(x = "Salaries of ME Graduates", y = "Cumulative Fraction") +
scale_y_continuous(limits = c(-0.05, 1.03),
expand = c(0,0),
breaks = seq(from = 0,
to = 1,
by = 0.1)) +
scale_x_continuous(labels = scales::label_dollar(scale = 0.001,
prefix = '$',
suffix = 'k'),
minor_breaks = seq(from = 0,
to = 450000,
by = 10000))+
geom_segment(data = data.frame(x = quantile(ordered_salaries$salary),
y = rep.int(-.05, 5),
xend = quantile(ordered_salaries$salary),
yend = seq(from = 0, to = 1, by = 0.25)),
aes(x = x, y = y, xend = xend, yend = yend),
color = "red",
linetype = "dashed") +
theme_bw() +
ggsave("./images/cdf_me_salaries.png", dpi = 150)
# alternate method if you don't want to calculate cumulative fractions
ordered_salaries %>%
ggplot2::ggplot(mapping = aes(x = salary)) +
geom_step(stat = "ecdf") + # "empirical cumulative distribution function"
labs(x = "Salaries of ME Graduates", y = "Cumulative Fraction") +
scale_y_continuous(limits = c(-0.05, 1.03),
expand = c(0,0),
breaks = seq(from = 0,
to = 1,
by = 0.1)) +
scale_x_continuous(labels = scales::label_dollar(scale = 0.001,
prefix = '$',
suffix = 'k'),
minor_breaks = seq(from = 0,
to = 450000,
by = 10000))+
geom_segment(data = data.frame(x = quantile(ordered_salaries$salary),
y = rep.int(-.05, 5),
xend = quantile(ordered_salaries$salary),
yend = seq(from = 0, to = 1, by = 0.25)),
aes(x = x, y = y, xend = xend, yend = yend),
color = "red",
linetype = "dashed") +
theme_bw(base_size = 15)
ggsave("./images/cdf_me_salaries.png", dpi = 150)
# alternate method if you don't want to calculate cumulative fractions
ordered_salaries %>%
ggplot2::ggplot(mapping = aes(x = salary)) +
geom_step(stat = "ecdf") + # "empirical cumulative distribution function"
labs(x = "Salaries of ME Graduates", y = "Cumulative Fraction") +
scale_y_continuous(limits = c(-0.05, 1.03),
expand = c(0,0),
breaks = seq(from = 0,
to = 1,
by = 0.1)) +
scale_x_continuous(labels = scales::label_dollar(scale = 0.001,
prefix = '$',
suffix = 'k'),
minor_breaks = seq(from = 0,
to = 450000,
by = 10000))+
geom_segment(data = data.frame(x = quantile(ordered_salaries$salary),
y = rep.int(-.05, 5),
xend = quantile(ordered_salaries$salary),
yend = seq(from = 0, to = 1, by = 0.25)),
aes(x = x, y = y, xend = xend, yend = yend),
color = "red",
linetype = "dashed") +
theme_bw(base_size = 13)
ggsave("./images/cdf_me_salaries.png", dpi = 150)
knitr::include_graphics("./images/cdf_me_salaries.png")
# boxplots to compare temperature in CO and HI
noaa_temp %>%
ggplot2::ggplot(mapping = aes(y = temp_hr_f,
x = location,
group = location)) +
geom_boxplot(mapping = aes(fill = location),
width = 0.5) +
ylab("Temperature, °F") +
xlab(NULL) +
theme_classic() +
theme(text = element_text(size=15),
legend.position = "none")
?cor
