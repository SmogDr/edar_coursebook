theme_bw()
#create two variables that are normally distributed
normal_data <- tibble(a = rnorm(n=1000, mean = 15, sd = 5),
b = rnorm(n=1000, mean = 10, sd = 3))
#add those variables together and you get a normal distribution
normal_data %>% mutate(c = a + b) -> normal_data
ggplot2::ggplot(data = normal_data) +
geom_histogram(aes(c),
bins = 30,
fill = "white",
color = "darkgrey") +
theme_minimal() +
theme(text = element_text(size=20))
ggsave("./images/hist_a_b.png", dpi = 150)
#multiply together three normal variables
normal_data %>%
mutate(d = sample(a*b*c, 1000)) -> log_data
ggplot2::ggplot(data = log_data) +
geom_histogram(aes(d),
bins = 30,
fill = "white",
color = "darkgrey") +
theme_minimal() +
theme(text = element_text(size=20))
ggsave("./images/hist_skew_out.png", dpi = 150)
#plot the same data on a log scale (x axis)
ggplot2::ggplot(data = log_data) +
geom_histogram(aes(d),
bins = 25,
fill = "white",
color = "darkgrey") +
theme_minimal() +
scale_x_log10() +
theme(text = element_text(size=20))
ggsave("./images/hist_skew_out_logx.png", dpi = 150)
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 30,
fill = "orange",
line = white) +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_bw()
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 30,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_bw()
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_bw()
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_minimal()
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_classic()
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_classic() +
xlab("") +
ylab("") +
theme(axis.title = element_blank())
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "orange",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_classic() +
xlab("") +
ylab("") +
theme(axis.title = element_blank(),
axis.text = element_blank())
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "purple",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_classic() +
xlab("") +
ylab("") +
theme(axis.title = element_blank(),
axis.text = element_blank())
plot_normal1
#sample a uniform distribution between 0 and 6, replicate 1000 times
#use 'ceiling' function to round up results
four_dice <- tibble(sum = replicate(10000, runif(4, min=0, max=6) %>%
ceiling() %>%
sum() #sum the result
))
plot_normal1 <- ggplot(data = four_dice)+
geom_histogram(aes(x = sum, after_stat(density)),
bins = 21,
fill = "navy",
color = "white") +
stat_function(fun = dnorm, n = 101,
args = list(
mean = mean(four_dice$sum),
sd = sd(four_dice$sum)
)
) +
theme_classic() +
xlab("") +
ylab("") +
theme(axis.title = element_blank(),
axis.text = element_blank())
plot_normal1
setwd("~/Documents/Research/R/Example files")
library(dplyr)
library(jsonlite)
# This function returns a two-column data frame containing data from the "List" service associated with the AQS API.
# The list service can be used to look up variable values that might be needed to generate data requests.
# Arguments:
# type: A character string specifying the type of data being requested. One of the following: states,
#       countiesByState, sitesByCounty, cbsas, classes, parametersByClass, pqaos, mas.
# email: A character string containing your email address registered with the AQS API.
# key: A character string containing the access key associated with your email.
# state: An integer or character string containing the FIPS code for the state.
#        Only needed to obtain countiesByState or sitesByCounty data.
# county: An integer or character string containing the FIPS code for the county.
#         Only needed to obtain sitesByCounty data.
# class: The AQS parameter class name. Only needed to obtain parametersByClass data. Default is "ALL".
# References: https://aqs.epa.gov/aqsweb/documents/data_api.html#lists
epa_api_list <- function(type, email, key, state=NULL, county=NULL, class="ALL"){
require(jsonlite)
# Check optional inputs
if(type %in% c("countiesByState","sitesByCounty")){
if(is.null(state)){
stop("The FIPS state code is required to retrieve a list of counties by state or a list of sites by county.", call.=F)
}else{
state <- sprintf("%02d", as.numeric(state))}}
if(type == "sitesByCounty"){
if(is.null(county)){
stop("The FIPS county code is required to retrieve the list of sites by county.", call.=F)
}else{
county <- sprintf("%03d", as.numeric(county))}}
# Generate URL
url <- sprintf("https://aqs.epa.gov/data/api/list/%s?email=%s&key=%s", type, email, key)
url <- switch(type,
"states"            = url,
"countiesByState"   = sprintf("%s&state=%s", url, state),
"sitesByCounty"     = sprintf("%s&state=%s&county=%s", url, state, county),
"cbsas"             = url,
"classes"           = url,
"parametersByClass" = sprintf("%s&pc=%s", url, toupper(class)),
"pqaos"             = url,
"mas"               = url,
stop("Invalid `type` value. Input `type` must be one of the following: states, countiesByState,
sitesByCounty, cbsas, classes, parametersByClass, pqaos, mas.", call.=F))
# Retrieve list
list <- fromJSON(url)$Data
}
# This function returns a data frame containing data from following services associated with the EPA AQS API:
# Monitors, Sample Data, Daily Summary Data, Annual Summary.
# Arguments:
# service: A character string specifying the service being accessed. One of the following: monitors, sampleData, dailyData, annualData.
# how: A character string specifying how the data will be selected  One of the following: bySite, byCounty, byState, byBox, byCBSA.
# email: A character string containing your email address registered with the AQS API.
# key: A character string containing the access key associated with your email.
# param: An integer or character string specifying the AQS parameter code.
# bdate: An integer or character string specifying the beginning date in the format YYYYMMDD.
#        If service is not "monitor", `bdate` and `edate` must be in the same year.
#        If service is "annualData", only the YYYY portion of the date will be used.
# edate: An integer or character string specifying the ending date in the format YYYYMMDD.
#        If service is not "monitor", `bdate` and `edate` must be in the same year.
#        If service is "annualData", only the YYYY portion of the date will be used.
# state: An integer or character string containing the FIPS code for the state.
#        Only needed if `how` is "bySite","byCounty", or "byState".
# county: An integer or character string containing the FIPS code for the county.
#         Only required and used if `how` is "bySite" or "byCounty".
# site: An integer or character string containing the AQS site number within the county.
#       Only required and used if `how` is "bySite".
# minlat, maxlat, minlon, maxlon: Numeric values specifying the minimum and maximum latitude and longitude (in decimal values)
#                                 associated with a geographic box. Only data north of `minlat` and south of `maxlat` will
#                                 be returned. Only data east of `minlon` and west of `maxlon` will be returned. North and
#                                 east are positive. Only required and used if `how` is "byBox".
# cbsa: An integer or character string containing the AQS Core Based Statistical Area code.
#       Only required and used if `how` is "byCBSA".
# References: https://aqs.epa.gov/aqsweb/documents/data_api.html
epa_api_data <- function(service, how, email, key, param, bdate, edate,
state=NULL, county=NULL, site=NULL, minlat=NULL, maxlat=NULL, minlon=NULL, maxlon=NULL, cbsa=NULL){
require(jsonlite)
# Check required inputs
if(!(service %in% c("monitors","sampleData","dailyData","annualData"))){
stop("Invalid `service` value.  Input `service` must be one of the following: monitors, sampleData, dailyData, annualData.", call.=F)
}
bdate <- as.character(bdate)
edate <- as.character(edate)
if((nchar(bdate) != 8) | (nchar(edate) != 8)){
stop("`bdate` and `edate` must have format YYYYMMDD.", call.=F)
}
if((service != "monitor") & (substr(bdate,1,4) != substr(edate,1,4))){
stop("`bdate` and `edate` must be in the same year.", call.=F)
}
# Check optional inputs
if(how %in% c("bySite","byCounty","byState")){
if(is.null(state)){
stop("The FIPS state code is required to retrieve data by site, county, or state.", call.=F)
}else{
state <- sprintf("%02d", as.numeric(state))}}
if(how %in% c("bySite","byCounty")){
if(is.null(county)){
stop("The FIPS county code is required to retrieve data by site or county.", call.=F)
}else{
county <- sprintf("%03d", as.numeric(county))}}
if(how == "bySite"){
if(is.null(site)){
stop("The AQS site number is required to retrieve data by site.", call.=F)
}else{
site <- sprintf("%04d", as.numeric(site))}}
if((how == "byBox") & (is.null(minlat) | is.null(maxlat) | is.null(minlon) | is.null(maxlon))){
stop("Inputs `minlat`, `maxlat`, `minlon`, and `maxlon` are required to retrieve data by box.", call.=F)
}
if(how == "byCBSA"){
if(is.null(cbsa)){
stop("The AQS CBSA code is required to retrieve data by CBSA.", call.=F)
}else{
cbsa <- sprintf("%05d", as.numeric(cbsa))}}
# Generate URL
url <- sprintf("https://aqs.epa.gov/data/api/%s/%s?email=%s&key=%s&param=%s&bdate=%s&edate=%s",
service, how, email, key, sprintf("%05d",as.numeric(param)), bdate, edate)
url <- switch(how,
"bySite"   = sprintf("%s&state=%s&county=%s&site=%s", url, state, county, site),
"byCounty" = sprintf("%s&state=%s&county=%s", url, state, county),
"byState"  = sprintf("%s&state=%s", url, state),
"byBox"    = sprintf("%s&&minlat=%f&maxlat=%f&minlon=%f&maxlon=%f", url, minlat, maxlat, minlon, maxlon),
"byCBSA"   = sprintf("%s&cbsa=%s", url, cbsa),
stop("Invalid `how` value. Input `how` must be one of the following: bySite, byCounty, byState, byBox, byCBSA.", call.=F))
# Retrieve data
data <- fromJSON(url)$Data
}
email  <- "john.volckens@colostate.edu"
key    <- "amberram32"
list_param <- epa_api_list(type="parametersByClass", email=email, key=key, class="criteria")
param <- dplyr::filter(list_param, grepl("ozone", value_represented, ignore.case=T))$code
list_state <- epa_api_list(type="states", email=email, key=key)
state <- dplyr::filter(list_state, grepl("colorado", value_represented, ignore.case=T))$code
list_county <- epa_api_list(type="countiesByState", email=email, key=key, state=state)
county <- dplyr::filter(list_county, grepl("larimer", value_represented, ignore.case=T))$code
list_monitors <- epa_api_data(service="monitors", how="byState", email=email, key=key, param=param,
bdate=20190101, edate=20191231, state=state)
list_monitors_fc <- dplyr::filter(list_monitors, grepl("fort collins", city_name, ignore.case=T))
list_cbsa <- epa_api_list(type="cbsas", email=email, key=key)
cbsa <- dplyr::filter(list_cbsa, grepl("fort collins", value_represented, ignore.case=T))$code
bdate <- 20190701
edate <- 20190731
data_site <- lapply(list_monitors_fc$site_number, epa_api_data, service="sampleData", how="bySite",
email=email, key=key, param=param, bdate=bdate, edate=edate, state=state, county=county) %>%
dplyr::bind_rows() %>%
dplyr::mutate(datetime = as.POSIXct(paste(date_gmt, time_gmt), tz="UTC"))
write_csv(data_site, path = "./ftc_o3.csv")
library(dplyr)
library(jsonlite)
library(tidyverse)
bdate <- 20190701
edate <- 20190731
View(list_monitors)
randomise <- function(f) f(runif(1e3))
randomize(mean)
randomise(mean)
runif(1e3)
randomise(sum)
randomise(min)
randomise(max)
lapply(mtcars, function(x) length(unique(x)))
lapply(mtcars, length(unique(x)))
lapply(mtcars, length(unique()))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(x) ^ 2, 0, pi)
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
?args
args(mean)
args(median)
args(ls)
args(graphics::plot.default)
count(args(ls))
sum(args(ls))
str(mean)
str(ls)
formals(ls)
length(formals(ls))
filter(objs, max(length(formals(ls))))
max(length(formals(ls)))
filter(objs, function(x) max(length(formals(x))))
max(length(formals(funs)))
max_l <- max(length(formals(x)))
max_l <- function(x) max(length(formals(x)))
lapply(funs, max_l)
which(LETTERS == "R")
lapply(funs, which(max_l))
View(max_l)
lng <- function(x) (length(formals(x)))
which(lng(funs) == max(lng(funs)))
max(lng(funs))
View(lng)
lng(funs)
formals(funs)
library(purrr)
map_dbl(funs, length(formals))
map(funs, length(formals))
lng(funs)
lapply(funs, max_l)
lapply(funs, max_l) -> list1
map_int(funs, length(formals))
funs %>% map(formals)
funs %>% map(formals) %>% map(length) -> lengths
list2 <- sort(lengths)
lengths <- funs %>% map(formals) %>% map_int(length)
sort(lengths)
sort(lengths) -> lengths2
tail(lengths2)
which(lengths == max(lengths))
which(lengths2 == max(lengths2))
length(funs$scan)
view(funs$scan)
funs$scan
formals(funs$scan)
length(formals(funs$scan))
library(repurrsive)
library(repurrrsive)
install.packages("repurrrsive")
library(repurrrsive)
x <- list(a = "a", b = 2)
x["a"]
x[["a"]]
x[1]
x[[1]]
(3:10)^2
got_chars
map(got_chars, "name")
map(got_chars[1:4], "name")
map(got_chars[1:10], "name")
str(got_chars)
glimpse(got_chars)
library(tidyverse)
glimpse(got_chars)
str(got_chars,max.level = 1)
str(got_chars,max.level = 2)
str(got_chars$name)
got_chars[1]
got_chars$name
got_chars["name"]
got_chars[["name"]]
got_chars[[name]]
list <- got_chars
View(list)
names(got_chars[1])
names(got_chars[[1]])
names(got_chars[[2]])
View(list)
got_chars[,18]
got_chars[[,18]]
got_chars[[.,18]]
got_chars[[1:30,18]]
got_chars[1:30,18]
got_chars[1:30]
got_chars[1]
got_chars[2]
got_chars[2,1]
got_chars[2,]
got_chars[[2]]
got_chars$playedBy
map(got_chars, "playedBy")
map_chr(got_chars[9:12], "name")
map_chr(got_chars, "name")
map_int(got_chars, 2)
map(got_chars, is.logical)
map(got_chars[1], is.logical)
map(got_chars[[1]], is.logical)
map_lgl(got_chars, "alive")
got_chars[1][2]
got_chars[[1]][[2]]
got_chars[[1]][[]]
got_chars[[1]]
got_chars[[]][[3]]
got_chars[[1:18]][[3]]
got_chars[1:18][[3]]
got_chars[[1]][[3]]
got_chars[[2]][[3]]
got_chars[[2]][[2:3]]
got_chars[[2]][2:3]
got_chars[[2]][2:5]
got_chars[1:2][[3]]
got_chars[1:2][3]
got_chars[1:2][c(3,3)]
got_chars[1:2][[c(3,3)]]
got_chars[3][3]
got_chars[3][[3]]
got_chars[[3]][[3]]
got_chars[[3]][[3:5]]
got_chars[[3]][[c(3,4,5)]]
got_chars[[3]][c(3,4,5)]
got_chars[[3]][3:5]
got_chars %>% map_chr(class)
got_chars[[1]] %>% map_chr(class)
class(got_chars)
class(got_chars[[1]])
class(got_chars[1])
